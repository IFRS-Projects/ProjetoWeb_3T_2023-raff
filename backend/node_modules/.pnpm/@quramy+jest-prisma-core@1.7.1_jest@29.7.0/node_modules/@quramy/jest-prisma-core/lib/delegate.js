"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrismaEnvironmentDelegate = void 0;
const chalk_1 = __importDefault(require("chalk"));
const loadDefaultClient_1 = require("./loadDefaultClient");
const DEFAULT_MAX_WAIT = 5000;
const DEFAULT_TIMEOUT = 5000;
class PrismaEnvironmentDelegate {
    getClient() {
        return this.prismaClientProxy;
    }
    constructor(config, context) {
        this.connected = false;
        this.triggerTransactionEnd = () => null;
        this.logBuffer = undefined;
        this.options = config.projectConfig.testEnvironmentOptions;
        this.testPath = context.testPath.replace(config.globalConfig.rootDir, "").slice(1);
    }
    async preSetup() {
        const self = this;
        const jestPrisma = {
            initializeClient: client => {
                if (this._originalClient) {
                    console.warn("jestPrisma has already set Prisma client instance.");
                }
                this._originalClient = client;
                this._originalClient.$on?.("query", (event) => {
                    this.logBuffer?.push(event);
                });
            },
            client: new Proxy({}, {
                get: (_, name) => {
                    if (!this.prismaClientProxy) {
                        console.warn("jsetPrisma.client should be used in test or beforeEach functions because transaction has not yet started.");
                        console.warn("If you want to access Prisma client in beforeAll or afterAll, use jestPrisma.originalClient.");
                    }
                    else {
                        return this.prismaClientProxy[name];
                    }
                },
            }),
            get originalClient() {
                return self.originalClient;
            },
        };
        return jestPrisma;
    }
    handleTestEvent(event) {
        if (event.name === "test_start") {
            return this.beginTransaction();
        }
        else if (event.name === "test_done" || event.name === "test_skip") {
            return this.endTransaction();
        }
        else if (event.name === "test_fn_start") {
            this.logBuffer = [];
        }
        else if (event.name === "test_fn_success" || event.name === "test_fn_failure") {
            this.dumpQueryLog(event.test);
            this.logBuffer = undefined;
        }
    }
    async teardown() {
        this.originalClient.$disconnect?.();
    }
    get originalClient() {
        if (!this._originalClient) {
            const originalClient = (0, loadDefaultClient_1.loadDefaultClient)(this.options);
            originalClient.$on("query", (event) => {
                this.logBuffer?.push(event);
            });
            this._originalClient = originalClient;
        }
        return this._originalClient;
    }
    async checkInteractiveTransaction() {
        const checker = () => Promise.resolve(null);
        try {
            await this.originalClient.$transaction(checker);
            return true;
        }
        catch {
            return false;
        }
    }
    async beginTransaction() {
        if (!this.connected) {
            await this.originalClient.$connect();
            const hasInteractiveTransaction = await this.checkInteractiveTransaction();
            if (!hasInteractiveTransaction) {
                throw new Error(`jest-prisma needs "interactiveTransactions" preview feature.`);
            }
            this.connected = true;
        }
        return new Promise(resolve => this.originalClient
            .$transaction(transactionClient => {
            this.prismaClientProxy = createProxy(transactionClient, this.originalClient, this.options);
            resolve();
            return new Promise((resolve, reject) => (this.triggerTransactionEnd = this.options.disableRollback ? resolve : reject));
        }, {
            maxWait: this.options.maxWait ?? DEFAULT_MAX_WAIT,
            timeout: this.options.timeout ?? DEFAULT_TIMEOUT,
        })
            .catch(() => true));
    }
    async endTransaction() {
        this.triggerTransactionEnd();
    }
    dumpQueryLog(test) {
        if (this.options.verboseQuery && this.logBuffer && this.logBuffer.length) {
            let parentBlock = test.parent;
            const nameFragments = [test.name];
            while (!!parentBlock) {
                nameFragments.push(parentBlock.name);
                parentBlock = parentBlock.parent;
            }
            const breadcrumb = [this.testPath, ...nameFragments.reverse().slice(1)].join(" > ");
            console.log(chalk_1.default.blue.bold.inverse(" QUERY ") + " " + chalk_1.default.gray(breadcrumb));
            for (const event of this.logBuffer) {
                console.log(`${chalk_1.default.blue("  jest-prisma:query")} ${event.query} -- params:${event.params}`);
            }
        }
    }
}
exports.PrismaEnvironmentDelegate = PrismaEnvironmentDelegate;
function fakeInnerTransactionFactory(parentTxClient, enableExperimentalRollbackInTransaction) {
    let seq = 1;
    const fakeTransactionMethod = async (arg) => {
        const savePointId = `test_${seq++}`;
        if (enableExperimentalRollbackInTransaction) {
            await parentTxClient.$executeRawUnsafe(`SAVEPOINT ${savePointId};`);
        }
        if (Array.isArray(arg)) {
            try {
                const results = [];
                for (const prismaPromise of arg) {
                    const result = await prismaPromise;
                    results.push(result);
                }
                if (enableExperimentalRollbackInTransaction) {
                    await parentTxClient.$executeRawUnsafe(`RELEASE SAVEPOINT ${savePointId};`);
                }
                return results;
            }
            catch (err) {
                if (enableExperimentalRollbackInTransaction) {
                    await parentTxClient.$executeRawUnsafe(`ROLLBACK TO SAVEPOINT ${savePointId};`);
                }
                throw err;
            }
        }
        else {
            try {
                const result = await arg(parentTxClient);
                if (enableExperimentalRollbackInTransaction) {
                    await parentTxClient.$executeRawUnsafe(`RELEASE SAVEPOINT ${savePointId};`);
                }
                return result;
            }
            catch (err) {
                if (enableExperimentalRollbackInTransaction) {
                    await parentTxClient.$executeRawUnsafe(`ROLLBACK TO SAVEPOINT ${savePointId};`);
                }
                throw err;
            }
        }
    };
    return fakeTransactionMethod;
}
function createProxy(txClient, originalClient, options) {
    const boundFakeTransactionMethod = fakeInnerTransactionFactory(txClient, options.enableExperimentalRollbackInTransaction ?? false);
    return new Proxy(txClient, {
        get: (target, name) => {
            const delegate = target[name];
            if (delegate)
                return delegate;
            if (name === "$transaction") {
                return boundFakeTransactionMethod;
            }
            if (originalClient[name]) {
                throw new Error(`Unsupported property: ${name.toString()}`);
            }
        },
    });
}
